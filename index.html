<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C.R.A.F.T. — Construction & Rapid Assembly Factory Terminal</title>
  <meta name="description" content="The orbital foundry for the multi-planetary era. On-demand space manufacturing, starting with habitats.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <canvas id="starfield"></canvas>

  <!-- Nav -->
  <nav class="nav">
    <span class="nav-wordmark">C.R.A.F.T.</span>
  </nav>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-image" id="heroImage"></div>
    <div class="hero-overlay"></div>
    <div class="hero-content">
      <h1 class="hero-title">C.R.A.F.T.</h1>
      <p class="hero-tagline">The orbital foundry for the multi-planetary era.</p>
    </div>
  </section>

  <!-- Main Content -->
  <section class="section">
    <h1 class="main-title">Construction & Rapid Assembly Factory Terminal</h1>
    <p class="statement statement-primary">We manufacture spacecraft parts and habitat infrastructure directly in LEO.</p>
    <p class="statement statement-secondary">By converting high-density raw feedstock into large-scale structures in-situ, we bypass rocket size constraints to build the industrial base for Earth orbit, the Moon, and Mars.</p>
  </section>

  <!-- Whitepaper -->
  <section class="section section-whitepaper">
    <button class="whitepaper-button">Read the Whitepaper</button>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-founders">
      <a href="https://www.linkedin.com/in/williamfahie/" target="_blank" rel="noopener">William Fahie</a>
      <a href="https://www.linkedin.com/in/harper-dammann-smith/" target="_blank" rel="noopener">Harper Dammann Smith</a>
    </div>
  </footer>

  <!-- Starfield -->
  <script>
    (function () {
      const canvas = document.getElementById('starfield');
      const ctx = canvas.getContext('2d');

      let width, height;
      const STAR_COUNT = 150;
      const stars = [];

      // Mouse tracking (relative to viewport center, normalized -1 to 1)
      let mouseX = 0;
      let mouseY = 0;
      let smoothMouseX = 0;
      let smoothMouseY = 0;
      const MOUSE_MULTIPLIER = 30;
      const LERP_FACTOR = 0.05;

      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      }

      function createStar() {
        const depth = 0.2 + Math.random() * 0.8; // 0.2–1.0
        return {
          x: Math.random() * width,
          y: Math.random() * height,
          radius: (0.5 + Math.random() * 1.5) * depth,
          baseOpacity: 0.3 + Math.random() * 0.7,
          depth: depth,
          drift: (0.1 + Math.random() * 0.2) * depth
        };
      }

      function init() {
        resize();
        stars.length = 0;
        for (let i = 0; i < STAR_COUNT; i++) {
          stars.push(createStar());
        }
      }

      function draw() {
        ctx.clearRect(0, 0, width, height);

        // Smooth mouse interpolation
        smoothMouseX += (mouseX - smoothMouseX) * LERP_FACTOR;
        smoothMouseY += (mouseY - smoothMouseY) * LERP_FACTOR;

        // Draw stars
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];

          // Ambient drift
          s.x += s.drift;
          if (s.x > width + 10) s.x = -10;

          // Parallax offset
          const px = s.x + smoothMouseX * s.depth * MOUSE_MULTIPLIER;
          const py = s.y + smoothMouseY * s.depth * MOUSE_MULTIPLIER;

          ctx.beginPath();
          ctx.arc(px, py, s.radius, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, ' + s.baseOpacity * s.depth + ')';
          ctx.fill();
        }

        requestAnimationFrame(draw);
      }

      // Resize with debounce
      let resizeTimer;
      window.addEventListener('resize', function () {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function () {
          resize();
          // Reposition stars that are now out of bounds
          for (let i = 0; i < stars.length; i++) {
            if (stars[i].x > width) stars[i].x = Math.random() * width;
            if (stars[i].y > height) stars[i].y = Math.random() * height;
          }
        }, 150);
      });

      // Mouse tracking
      window.addEventListener('mousemove', function (e) {
        mouseX = (e.clientX - width / 2) / (width / 2);
        mouseY = (e.clientY - height / 2) / (height / 2);
      });

      init();
      requestAnimationFrame(draw);
    })();
  </script>

  <!-- Scroll Fade -->
  <script>
    (function () {
      const heroImage = document.getElementById('heroImage');
      const hero = document.querySelector('.hero');
      let ticking = false;

      function updateHeroOpacity() {
        const rect = hero.getBoundingClientRect();
        const heroHeight = hero.offsetHeight;
        const scrolled = -rect.top;
        const progress = Math.max(0, Math.min(1, scrolled / (heroHeight * 0.9)));
        heroImage.style.opacity = 1 - progress;
        ticking = false;
      }

      window.addEventListener('scroll', function () {
        if (!ticking) {
          requestAnimationFrame(updateHeroOpacity);
          ticking = true;
        }
      }, { passive: true });

      updateHeroOpacity();
    })();
  </script>

  <!-- Hero Entrance -->
  <script>
    (function () {
      var title = document.querySelector('.hero-title');
      var tagline = document.querySelector('.hero-tagline');

      // Fade in title after brief delay
      setTimeout(function () {
        title.classList.add('visible');
      }, 300);

      // Slide-up tagline right after fade-in completes
      setTimeout(function () {
        tagline.classList.add('visible');
      }, 800);
    })();
  </script>

  <!-- Word-by-Word Scroll Spotlight -->
  <script>
    (function () {
      // Wrap each word in a span
      const statements = document.querySelectorAll('.statement');
      statements.forEach(function (statement) {
        const text = statement.textContent;
        const words = text.split(' ');
        statement.innerHTML = words.map(function (word) {
          return '<span class="word">' + word + '</span>';
        }).join(' ');
      });

      // Track scroll direction
      let lastScrollY = window.scrollY;
      let ticking = false;
      
      function updateWordVisibility() {
        const currentScrollY = window.scrollY;
        const scrollingDown = currentScrollY > lastScrollY;
        
        const words = document.querySelectorAll('.statement .word');
        const windowHeight = window.innerHeight;
        const centerY = windowHeight / 2;
        const threshold = windowHeight * 0.15;
        
        words.forEach(function (word) {
          const rect = word.getBoundingClientRect();
          const wordCenter = rect.top + rect.height / 2;
          const hasClass = word.classList.contains('fade-in');
          
          // Word is in the spotlight - illuminate it
          if (wordCenter >= centerY - threshold && wordCenter <= centerY + threshold) {
            if (!hasClass) {
              word.classList.add('fade-in');
            }
          } 
          // Word is above the spotlight (already passed through)
          else if (wordCenter < centerY - threshold) {
            if (!scrollingDown && hasClass) {
              // Only when scrolling UP, remove the fade-in
              word.classList.remove('fade-in');
            }
            // When scrolling down, absolutely do nothing - preserve the class
          }
          // Words below the spotlight - don't add or remove anything
        });
        
        lastScrollY = currentScrollY;
        ticking = false;
      }

      window.addEventListener('scroll', function () {
        if (!ticking) {
          requestAnimationFrame(updateWordVisibility);
          ticking = true;
        }
      }, { passive: true });

      // Initial check
      updateWordVisibility();

      // Observe button separately
      const button = document.querySelector('.whitepaper-button');
      if (button) {
        const buttonObserver = new IntersectionObserver(function (entries) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
              entry.target.classList.add('fade-in');
            }
          });
        }, {
          root: null,
          rootMargin: '-100px 0px -100px 0px',
          threshold: 0.5
        });
        buttonObserver.observe(button);
      }
    })();
  </script>

</body>
</html>
