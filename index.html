<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C.R.A.F.T. — Construction & Rapid Assembly Factory Terminal</title>
  <meta name="description" content="The orbital foundry for the multi-planetary era. On-demand space manufacturing, starting with habitats.">
  <link rel="icon" type="image/png" href="C.R.A.F.T..png">
  <link rel="apple-touch-icon" href="C.R.A.F.T..png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Space+Grotesk:wght@300;400;600;700;900&display=swap&text-rendering=optimizeLegibility" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <canvas id="starfield"></canvas>

  <!-- Nav -->
  <nav class="nav">
    <span class="nav-wordmark">C.R.A.F.T.</span>
    <button class="nav-button" id="learnMoreBtn">Learn More</button>
  </nav>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-image" id="heroImage"></div>
    <div class="hero-overlay"></div>
    <div class="hero-content">
      <h1 class="hero-title">C.R.A.F.T.</h1>
      <p class="hero-tagline">The orbital foundry for the multi-planetary era.</p>
    </div>
  </section>

  <!-- Problem Statements -->
  <section class="section section-problems">
    <div class="problem-item">
      <h2 class="problem-title"><span class="highlight-number">80%</span> OF A MODERN SPACE STATION IS DEAD WEIGHT.</h2>
      <p class="problem-description">Current modules are over-engineered to survive the 8-minute vibration of launch—rendering them inefficient for the decades they spend in orbit.</p>
    </div>
    <div class="problem-item">
      <h2 class="problem-title">WE ARE CURRENTLY PAYING TO SHIP AIR.</h2>
      <p class="problem-description">A Starship fairing can hold 150 tons of mass, but pre-built habitats are so voluminous they "max out" the rocket at only 30 tons. We are wasting 70% of the world's most powerful launch capacity.</p>
    </div>
    <div class="problem-item">
      <h2 class="problem-title">THE INFLECTION TO A <span class="highlight-number">$1.8 TRILLION</span> ECONOMY.</h2>
      <p class="problem-description">Space is no longer a destination; it's a production center. C.R.A.F.T. is the industrial backbone required to scale LEO real estate and deep-space logistics to meet the demands of a trillion-dollar orbital market.</p>
    </div>
  </section>

  <!-- Main Content -->
  <section class="section">
    <p class="eyebrow">OUR SOLUTION</p>
    <h1 class="main-title">Construction & Rapid Assembly Factory Terminal: C.R.A.F.T.</h1>
    <p class="statement statement-primary">We manufacture spacecraft parts and habitat infrastructure directly in LEO.</p>
    <p class="statement statement-secondary">By converting high-density raw feedstock into large-scale structures in-situ, we bypass rocket size constraints to build the industrial base for Earth orbit, the Moon, and Mars.</p>
  </section>

  <!-- Whitepaper -->
  <section class="section section-whitepaper">
    <button class="whitepaper-button">Read the Whitepaper</button>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-founders">
      <a href="https://www.linkedin.com/in/williamfahie/" target="_blank" rel="noopener">William Fahie</a>
      <a href="https://www.linkedin.com/in/harper-dammann-smith/" target="_blank" rel="noopener">Harper Dammann Smith</a>
    </div>
  </footer>

  <!-- Learn More Button Scroll -->
  <script>
    (function () {
      const learnMoreBtn = document.getElementById('learnMoreBtn');
      const problemSection = document.querySelector('.section-problems');
      
      if (learnMoreBtn && problemSection) {
        learnMoreBtn.addEventListener('click', function () {
          problemSection.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
          });
        });
      }
    })();
  </script>

  <!-- Starfield -->
  <script>
    (function () {
      const canvas = document.getElementById('starfield');
      const ctx = canvas.getContext('2d');

      let width, height;
      const STAR_COUNT = 300;
      const stars = [];

      // Mouse tracking (absolute pixel position)
      let mouseX = -1000;
      let mouseY = -1000;
      const REPULSION_RADIUS = 150;
      const REPULSION_STRENGTH = 2;

      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      }

      function createStar() {
        const depth = 0.2 + Math.random() * 0.8; // 0.2–1.0
        return {
          x: Math.random() * width,
          y: Math.random() * height,
          baseX: 0,
          baseY: 0,
          radius: (0.5 + Math.random() * 1.5) * depth,
          baseOpacity: 0.3 + Math.random() * 0.7,
          depth: depth,
          drift: (0.4 + Math.random() * 0.8) * depth
        };
      }

      function init() {
        resize();
        stars.length = 0;
        for (let i = 0; i < STAR_COUNT; i++) {
          const star = createStar();
          star.baseX = star.x;
          star.baseY = star.y;
          stars.push(star);
        }
      }

      function draw() {
        ctx.clearRect(0, 0, width, height);

        // Draw stars
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];

          // Ambient drift
          s.baseX += s.drift;
          if (s.baseX > width + 10) {
            s.baseX = -10;
          }

          // Calculate distance from mouse
          const dx = mouseX - s.baseX;
          const dy = mouseY - s.baseY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          let px = s.baseX;
          let py = s.baseY;

          // Apply repulsion if within radius
          if (distance < REPULSION_RADIUS && distance > 0) {
            const force = (REPULSION_RADIUS - distance) / REPULSION_RADIUS;
            const repelX = (dx / distance) * force * REPULSION_STRENGTH * -30;
            const repelY = (dy / distance) * force * REPULSION_STRENGTH * -30;
            px += repelX;
            py += repelY;
          }

          ctx.beginPath();
          ctx.arc(px, py, s.radius, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, ' + s.baseOpacity * s.depth + ')';
          ctx.fill();
        }

        requestAnimationFrame(draw);
      }

      // Resize with debounce
      let resizeTimer;
      window.addEventListener('resize', function () {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function () {
          resize();
          // Reposition stars that are now out of bounds
          for (let i = 0; i < stars.length; i++) {
            if (stars[i].x > width) stars[i].x = Math.random() * width;
            if (stars[i].y > height) stars[i].y = Math.random() * height;
          }
        }, 150);
      });

      // Mouse tracking
      window.addEventListener('mousemove', function (e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      init();
      requestAnimationFrame(draw);
    })();
  </script>

  <!-- Scroll Fade -->
  <script>
    (function () {
      const heroImage = document.getElementById('heroImage');
      const hero = document.querySelector('.hero');
      let ticking = false;

      function updateHeroOpacity() {
        const rect = hero.getBoundingClientRect();
        const heroHeight = hero.offsetHeight;
        const scrolled = -rect.top;
        const progress = Math.max(0, Math.min(1, scrolled / (heroHeight * 0.9)));
        heroImage.style.opacity = 1 - progress;
        ticking = false;
      }

      window.addEventListener('scroll', function () {
        if (!ticking) {
          requestAnimationFrame(updateHeroOpacity);
          ticking = true;
        }
      }, { passive: true });

      updateHeroOpacity();
    })();
  </script>

  <!-- Hero Entrance -->
  <script>
    (function () {
      var title = document.querySelector('.hero-title');
      var tagline = document.querySelector('.hero-tagline');

      // Character-by-character animation
      var text = title.textContent;
      title.innerHTML = '';
      
      for (var i = 0; i < text.length; i++) {
        var span = document.createElement('span');
        span.textContent = text[i];
        span.style.opacity = '0';
        span.style.display = 'inline-block';
        span.style.transform = 'translateY(20px) rotate(' + (Math.random() * 4 - 2) + 'deg)';
        span.style.transition = 'opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), transform 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
        title.appendChild(span);
      }

      // Animate characters with stagger
      setTimeout(function () {
        title.classList.add('visible');
        var chars = title.querySelectorAll('span');
        chars.forEach(function (char, index) {
          setTimeout(function () {
            char.style.opacity = '1';
            char.style.transform = 'translateY(0) rotate(0deg)';
          }, index * 40);
        });
      }, 400);

      // Tagline follows with elegant delay
      setTimeout(function () {
        tagline.classList.add('visible');
      }, 400 + (text.length * 40) + 300);
    })();
  </script>

  <!-- Problem Statements Animation -->
  <script>
    (function () {
      const problemItems = document.querySelectorAll('.problem-item');
      const eyebrows = document.querySelectorAll('.eyebrow');
      
      // Animate eyebrows
      const eyebrowObserver = new IntersectionObserver(function (entries) {
        entries.forEach(function (entry) {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            eyebrowObserver.unobserve(entry.target);
          }
        });
      }, {
        root: null,
        rootMargin: '-50px',
        threshold: 0.5
      });
      
      eyebrows.forEach(function (eyebrow) {
        eyebrowObserver.observe(eyebrow);
      });
      
      // Animate problem items
      const observer = new IntersectionObserver(function (entries) {
        entries.forEach(function (entry) {
          if (entry.isIntersecting) {
            const index = Array.from(problemItems).indexOf(entry.target);
            const randomRotation = Math.random() * 4 - 2; // -2 to 2 degrees
            // Stagger with longer delays for Apple-like feel
            setTimeout(function () {
              entry.target.style.transform = 'translateY(0) scale(1) rotateX(' + randomRotation + 'deg)';
              entry.target.classList.add('visible');
            }, index * 400);
            observer.unobserve(entry.target);
          }
        });
      }, {
        root: null,
        rootMargin: '-50px',
        threshold: 0.15
      });

      problemItems.forEach(function (item) {
        observer.observe(item);
      });
    })();
  </script>

  <!-- Main Title Animation -->
  <script>
    (function () {
      const mainTitle = document.querySelector('.main-title');
      
      if (mainTitle) {
        const observer = new IntersectionObserver(function (entries) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting) {
              entry.target.classList.add('visible');
              observer.unobserve(entry.target);
            }
          });
        }, {
          root: null,
          rootMargin: '-80px',
          threshold: 0.1
        });
        
        observer.observe(mainTitle);
      }
    })();
  </script>

  <!-- Smooth Parallax Scrolling -->
  <script>
    (function () {
      let ticking = false;
      const problemSection = document.querySelector('.section-problems');
      const mainSection = document.querySelectorAll('.section')[1];
      
      function updateParallax() {
        const scrolled = window.pageYOffset;
        
        // Subtle parallax on problem statements
        if (problemSection) {
          const rect = problemSection.getBoundingClientRect();
          if (rect.top < window.innerHeight && rect.bottom > 0) {
            const offset = (window.innerHeight - rect.top) * 0.1;
            problemSection.style.transform = 'translateY(' + offset + 'px)';
          }
        }
        
        // Very subtle parallax on main content
        if (mainSection) {
          const rect = mainSection.getBoundingClientRect();
          if (rect.top < window.innerHeight && rect.bottom > 0) {
            const offset = (window.innerHeight - rect.top) * 0.05;
            mainSection.style.transform = 'translateY(' + offset + 'px)';
          }
        }
        
        ticking = false;
      }
      
      window.addEventListener('scroll', function () {
        if (!ticking) {
          requestAnimationFrame(updateParallax);
          ticking = true;
        }
      }, { passive: true });
    })();
  </script>

  <!-- Word-by-Word Scroll Spotlight -->
  <script>
    (function () {
      // Wrap each word in a span
      const statements = document.querySelectorAll('.statement');
      statements.forEach(function (statement) {
        const text = statement.textContent;
        const words = text.split(' ');
        statement.innerHTML = words.map(function (word) {
          return '<span class="word">' + word + '</span>';
        }).join(' ');
      });

      // Scroll-based word spotlight effect with enhanced smoothness
      let ticking = false;
      
      function updateWordVisibility() {
        const words = document.querySelectorAll('.statement .word');
        const windowHeight = window.innerHeight;
        const centerY = windowHeight * 0.55; // Slightly lower sweet spot
        
        words.forEach(function (word) {
          const rect = word.getBoundingClientRect();
          const wordCenter = rect.top + rect.height / 2;
          
          // Calculate distance from center of viewport
          const distance = Math.abs(wordCenter - centerY);
          const threshold = windowHeight * 0.2; // Slightly wider spotlight
          
          // Illuminate when in spotlight with smooth gradient
          if (distance < threshold) {
            word.classList.add('fade-in');
          } 
          // Only de-illuminate if word is BELOW center
          else if (wordCenter > centerY + threshold) {
            word.classList.remove('fade-in');
          }
        });
        
        ticking = false;
      }

      window.addEventListener('scroll', function () {
        if (!ticking) {
          requestAnimationFrame(updateWordVisibility);
          ticking = true;
        }
      }, { passive: true });

      // Initial check
      updateWordVisibility();

      // Observe button separately
      const button = document.querySelector('.whitepaper-button');
      if (button) {
        const buttonObserver = new IntersectionObserver(function (entries) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
              entry.target.classList.add('fade-in');
            }
          });
        }, {
          root: null,
          rootMargin: '-100px 0px -100px 0px',
          threshold: 0.5
        });
        buttonObserver.observe(button);
        
        // Magnetic button effect
        button.addEventListener('mousemove', function (e) {
          const rect = button.getBoundingClientRect();
          const x = e.clientX - rect.left - rect.width / 2;
          const y = e.clientY - rect.top - rect.height / 2;
          button.style.transform = 'translate(' + (x * 0.15) + 'px, ' + (y * 0.15) + 'px) scale(1.02)';
        });
        
        button.addEventListener('mouseleave', function () {
          button.style.transform = 'translate(0, 0) scale(1)';
        });
      }
    })();
  </script>

</body>
</html>
